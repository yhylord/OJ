Tsinsen A1295 necklace

【题目大意】

一个串的每一位都可以是M(2 <= M <= 10)种颜色中的一种，定义一个串的幸运度为最长相同颜色子串的长度。

给出长度为N(2 <= N <= 1000)的串每一位是每种颜色的概率，求这个串幸运度的期望。

【算法分析】

一个直接的递推状态是用f(i, j, k, l)表示到第i位，当前连续长度为j，历史最大长度为k，当前位为l的概率。

那么，很显然，枚举下一位就可以完成转移。然而这样状态已经O(N^3M)了，外加转移的O(M)，总时间复杂度O(N^3M^2)。

要想有飞跃，必须改变状态表示。突破口在于，我们可以把当前连续长度这一维给去掉，变为枚举上一次不同位在哪里。

这样，状态已经被我们优化到O(N^2M)了，即用f(i, j, k)表示到第i位，历史最大长度为j，当前位为k的概率。

那么，我们要使用O(1)的时间完成转移，很容易想到部分和优化。

转移分为两种情况。

第一种，最后一段长度 = 历史最大长度，那么f(i, j, k)要加上sigma{f(i - j, p, q) * probability(i - j + 1, i, k)}(1 <= p <= j, 1 <= q <= M && q != k)，显然是可以部分和的。

第二种，最后一段长度 < 历史最大长度，那么f(i, j, k)要加上sigma{f(i - p, j, q) * probability(i - p + 1, i, k)}(1 <= p < j，1 <= q <= M && q != k)，显然也是可以部分和的，取出一段和的时候可以使用类似取出一段hash的计算方法。

其中probability(i, j, k)表示从第i位到第j位全都为k的概率，是可以在O(N^2M)的时间内预处理出来的。

整体时间复杂度O(N^2M)。
