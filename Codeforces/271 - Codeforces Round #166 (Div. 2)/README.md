271 - Codeforces Round #166 (Div. 2)

A. Beautiful Year

【题目大意】

给出年份y(1000 <= y <= 9000)，求大于y的最小的四位数字各不相同的年份。

【算法分析】

枚举，时间复杂度O(Y)。

B. Prime Matrix

【题目大意】

给一个N * M(1 <= N, M <= 500)的矩阵（每个正整数不超过10^5），每一步可以对矩阵中某个数加1，求最少的步数使得矩阵中至少有一行或一列都是素数。

【算法分析】

先预处理10^5以内的每个数变成素数需要加几，这个可以在筛法的过程中完成。枚举全素的那一行/列，分别计算答案取最小的即可，时间复杂度O(NM)。

C. Secret

【题目大意】

给出将1 ~ N分成K个不相交集合(2 <= K <= N <= 10^6)，使得每个集合不构成等差数列（势至少大于等于3）的一种可行方案。

【算法分析】

首先，N < 3 * K为无解情况。然后，我们排出1 1 2 2 3 3 ... K K 1 2 3 ... K，其中必然不存在等差数列，剩下的N - 3 * K个数就随意了，时间复杂度O(N)。

D. Good Substrings

【题目大意】

给出26个小写字母中哪些是好的，哪些是坏的，求给出的长度为N的字符串(1 <= N <= 1500)有多少个包含坏字母不超过K个的不同子串。

【算法分析】

算法一：枚举子串起点，依次插入一个Trie中，从而避免重复问题。过程中统计坏字母个数即可，时间复杂度O(N^2)。

算法二：使用倍增算法实现后缀数组，按后缀大小顺序依次计算，每次加入max(以sa(i)为起点坏字母不超过K个的最长延伸长度L - height(i), 0)，其中L可以使用二分实现，时间复杂度O(NlogN)。

算法三：思路同上，但使用DC3算法实现后缀数组，同时采用左右指针移动的扫描方法完成L的预处理，时间复杂度O(N)。

E. Three Horses

【题目大意】

给出N(1 <= N <= 10^5)个整数a_1, ..., a_N(1 <= a_i <= 10^9)和M(2 <= M <= 10^9)，求出数对(x, y)(1 <= x < y <= M)的个数，使得初始数对(x, y)经过一系列操作后，在过程中得到的所有数对包含(1, a_i)。对于(a, b)可以生成(a + 1, b + 1)，对于偶数对(a, b)可以生成(a / 2, b / 2)，对于数对(a, b)和(b, c)可以生成(a, c)。

【算法分析】

考虑三种操作，我们发现，让最后的一系列操作全是除法是必然可以的。那么，我们令y - x = d，第三种操作可以使两个数的差变为原来的k倍，则除法之前必然变成了(2^t, 2^t + kd)。

由于k任意，则必存在k = 2^t * p，那么就可以表示为(2^t, 2^t(1 + pd))，除完后得到(1, 1 + pd)。因此，如果d是所有a_i - 1的公约数，必然是合法的。

但同时考虑到，由于除法的存在，假如d' = d * 2^r，仍然可以得到d。所以我们的做法是，求出gcd(a_i)的所有奇因子，并将它们的2^r倍对应的解的个数计算入答案，时间复杂度O(NlogN)。
