191 - Codeforces Round #121 (Div. 1)

E. Thwarting Demonstrations

【题目大意】

给出一个长度为N(1 <= N <= 10^5)的序列，求第K(1 <= K <= N * (N + 1) / 2)大子段和。

【算法分析】

直接求明显是不现实的，因此我们想到二分答案C再进行验证，大于等于C的数大于等于K个的最大的C即为答案。

下面要考虑的问题就是如何求大于等于C的数的个数。由于是针对所有子段，我们很容易想到要枚举子段的右端点。

考虑部分和s_0, s_1, ..., s_N，对于右端点i，我们只要知道在s_0, s_1, ..., s_(i - 1)里小于等于s_i - C的数的个数即可。

这样的话，就变成一个用高级数据结构来维护的问题了。

转化问题一：不断查询a_i, a_(i + 1), ..., a_j里小于等于C的数的个数。那么显然可以离散化后用可持久化线段树来维护。

转化问题二：依次查询a_1，a_2, ..., a_(i - 1)里小于等于C的数的个数，并插入a_i。那么这样可以直接用平衡树来维护，或者离散化后用树状数组来维护。

以上方法的时间复杂度均为O(Nlog^2N)。
