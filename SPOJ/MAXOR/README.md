SPOJ MAXOR

【题目大意】

给出一个N(1 <= N <= 12000)个数的序列A和M(1 <= M <= 6000)次询问，每次询问[l, r]内的最大连续异或和。

【算法分析】

首先我们把题目转化一下，求异或前缀和s。

那么，a_i xor a_(i + 1) xor a_(i + 2) xor ... xor a_j = s_j xor s_(i - 1)。

所以，对于区间[l, r]，我们要求的就是s_i xor s_j(l - 1 <= i < j <= r)的最大值。

我们知道，使用可持久化Trie在logN的时间内得到一个数与一个区间内任意数异或和的最大值。

那么，我们尝试把这N个数分成K块，每块长度为L，每块有个块头。

对于每个块头p，我们可以在NlogN的时间内预处理出[p, i](p < i <= N)内任意两个s异或和的最大值。

那么，对于一个询问[l, r]，我们可以先从s_l开始暴力查询其在这个区间内与另一个数异或的最大值，直到找到下一个块头，就有了之前预处理的答案。

时间复杂度O((KN + LM)logA)。
