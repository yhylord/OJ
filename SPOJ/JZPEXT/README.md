SPOJ JZPEXT

【题目大意】

定义一个数为优美的数，当且仅当它被自己的所有非零数位整除。

给出T(1 <= T <= 25000)组询问[L, R](1 <= L <= R <= 10^18)，求区间[L, R]里的优美的数个数。

【算法分析】

首先，一个直接的数位DP思路是f[less][dep][state][rem]，2^9的state表示取过哪几个数字，2520的rem表示模2520的余数。

因为2520是1 ~ 9的最小公倍数，那么如果i(1 ~ 9)整除rem即说明i整除原数。

然而这样的复杂度是18 * 512 * 2520 * 10的，1s时限过不了。

我们发现，2^9的状态太浪费了，实际上，我们只需要记录取过的数的最小公倍数看最后能否整除rem就可以了。

而这些最小公倍数都是2520的约数，一共只有50个不到。

同时，2520的状态太浪费了，我们发现，每次向下枚举一位都是(rem * 10 + i) mod 2520。

那么到最后一位的时候先给了之前的数2和5两个因子，整个能不能多整除一个2和5只取决于i。

因此，之前只需要记录模252的余数就可以了。

现在复杂度18 * 50 * 252 * 10，询问25000 * 18，大概差不多了。

还要注意每次* 10 + i取模要用数组预处理，求最小公倍数也要预处理，这样就可以过了。
