SPOJ BST

【题目大意】

模拟一棵二叉排序树，输入一个1 ~ N(1 <= N <= 300000)的排列，按顺序插入这些数，统计每次插入的过程中访问了多少个结点。

【算法分析】

我们发现，每次插入以后，它的父亲结点一定是此前比它大的最接近的数和比它小的最接近的数中位置靠后的一个。

那么，很显然插入它访问的结点个数 = 插入它父亲访问的结点个数 + 1。

我们要做的就是求出在插入每个数之前找最接近的数，考虑排序后的新数列。

由于是1 ~ N的排列，我们不用排序就知道原数列中每个数在新数列中的位置。

我们根据原数列的顺序倒着做，每次找它在新数列中的前驱和后继在原数列中对应的位置里靠后的一个作为父亲。

之后把它在新数列中删除，继续做，显然可以用双向链表维护。

时间复杂度O(N)。
