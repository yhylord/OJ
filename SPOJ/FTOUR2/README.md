SPOJ FTOUR2

【题目大意】

给出N(1 <= N <= 200000)个结点的树，其中有M个是黑结点，求包含不超过K个黑点的路径的最长长度。

【算法分析】

首先我们对这棵树进行点分治，接下来考虑处理以root为根的子树。

倘若随意地更新答案，由于更新的是一个区间，其状态总量是非常大的。

那么，我们考虑把root的儿子按路径上最多黑结点个数从大到小排序，用b[i](0 <= i <= K)表示过root的包含不超过i个黑结点的路径的最长长度。

设从某个儿子走下去路径最多黑结点个数为R，则我们用a[i](0 <= i <= R)表示从这个儿子走下去路径上有i个黑结点的最长长度。

第一步考虑利用之前的b和当前的a更新答案，即a[i] + b[K - i](0 <= i <= R)。

第二步考虑利用当前的a来更新b，我们发现，由于保证了R的单调减，需要更新的b的元素个数最多为R（再多以后的第一步不可能用到），因此我们只要更新b[i](K - R <= i <= K)即可。

注意更新的时候需要考虑[0, R]和[K - R, K]相交的情况。

分析复杂度，枚举每个儿子时，其R必然小于等于这个儿子的大小，因此对a, b的更新过程必然不超过以root为根的子树的总结点数。

因此，更新的总复杂度为O(NlogN)。此外，每个点最多在一次排序中，其复杂度仍为O(NlogN)。综上，算法整体时间复杂度O(NlogN)。
